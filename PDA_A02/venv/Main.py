'''
Project B
Programming for Data Analytics
Haithem Alfi

@author: colinoriordan
@StudentID: R00133939
@Email: colin.r.oriordan@mycit.ie
@class: SD3B

Project objective is to produce an application and report that allows the
user to explore some of the most interesting aspects of the IMDB dataset,
using Pandas where possible as a means of analysing the data and incorporating
visualization as method of illustrating the results.

Accompanying this application is a short report, which includes a summary
of the findings, mainly showing the graphical output generated by the
application.

'''

# import modules
import sys
import numpy as np
import pandas as pd
from bidict import bidict


def main_menu():
    '''
    The starting point of the execution of the application.
    Purpose is to display a menu of options to the user,
    and to control the flow of the application depending
    on the user's selection.
    '''

    # Verifies the program is being run with python version 3.0 or later
    if sys.version_info[0] < 3:
        raise Exception("Python 3 or a more recent version is required.")

    # create the boolean variable close to decide when our loop ends
    close = False

    # menu is displayed as long as close is false ( until user selects exit )
    while close is False:

        # we display our menu on screen
        print("\n\n1. Most successful directors or actors")
        print("2. Film comparison")
        print("3. Analyse the distribution of gross earnings")
        print("4. Genre Analysis")
        print("5. Earnings and IMDB scores")
        print("6. Exit")

        # get user choice input in range 1-6
        choice = get_num_input(1, 7, False)

        # select a function call based on user's response'
        if choice == 1:
            most_successful()
        elif choice ==6:
            close = True

    # program terminated
    sys.exit()


def get_num_input(lower_boundary, higher_boundary, roman):
    '''
    Using the parameters of lower & higher boundary, the function
    gets the user's input within this range and returns it.
    Function will loop until the user enters a value that is of the
    correct data type in the specified range.

    :param lower_boundary: lower boundary of valid integer values
    :param higher_boundary: higher boundary of valid integer values
    :param roman: boolean that indicates if the selection is in roman numerals
    :return choice: the valid user selection
    '''

    # create bi-directional dictionary of roman numeral to integer
    roman_integer_bidict = bidict({
        "i": 1,
        "ii": 2,
        "iii": 3,
        "iv": 4,
        "v": 5,
        "vi": 6,
        "vii": 7,
        "viii": 8,
        "ix": 9,
        "x": 10
    })

    # create the boolean variable valid_int to determine if user input is valid.
    valid_input = False

    # loop the users input until a valid response in range is entered
    while valid_input is False:

        # if the range is not in roman numerals i.e. integers
        if not roman:
            # throws exception if the response is not an integer
            try:
                choice = int(input("\nPlease select one of the above options:"))
            except ValueError:
                print("\nThis is not a valid data type response. "
                      f"Integer {lower_boundary} to {higher_boundary-1}.")
                continue

            # print error if response is not in correct range 1-6
            if choice in range(lower_boundary, higher_boundary):
                valid_input = True
            else:
                print("\nThis integer response is not in range "
                      f"{lower_boundary} to {higher_boundary-1}.")

        # else if the range is in roman numerals
        elif roman:
            # reads user input
            choice = input("\nPlease select one of the above options:")

            # if the user's input is numeric or a decimal -> print error & loop back to input
            if choice.isnumeric() or choice.isdecimal():
                print("\nThis numeric or decimal data type is not a valid roman numeral response in range "
                      f"{roman_integer_bidict.inv[lower_boundary]} to "
                      f"{roman_integer_bidict.inv[higher_boundary-1]}.")
                continue

            # else the users input is a string/character type
            else:

                # change the user's input to lower case
                choice.lower()

                # if the user's choice is a roman numeral, take this value & assign
                # it's corresponding integer value to choice variable.
                if choice in roman_integer_bidict:
                    choice = roman_integer_bidict[choice]

                    # if the corresponding integer value is in the correct range, this is valid.
                    if choice in range(lower_boundary, higher_boundary):
                        valid_input = True

                    # error printed if the user enters a roman numeral that is not in range & loop back to input.
                    else:
                        print("\nThis roman numeral response is not in range "
                              f"{roman_integer_bidict.inv[lower_boundary]} to "
                              f"{roman_integer_bidict.inv[(higher_boundary-1)]}.")

                # error printed if the user enters a string, that's not a roman numeral & loop back to input
                else:
                    print("\nThis is not a roman numeral response in range "
                          f"{roman_integer_bidict.inv[lower_boundary]} to "
                          f"{roman_integer_bidict.inv[higher_boundary-1]}.")

    return choice


def most_successful():
    '''
    Sub menu to display sub options of most successful Actor / Director to user.
    Controls the flow of the application under the most successful option
    depending on the user's input choice.
    '''

    # we display our menu on screen
    print("\ni. Top Directors")
    print("ii. Top Actors")

    # get user choice input in range i to ii
    # Execution will loop here until a valid response is received.
    choice = get_num_input(1, 3, True)

    # set our display text based on user option
    if choice == 1:
        text = "directors"
    else:
        text = "actors"

    print(f"\nPlease enter the number of top {text}, based on gross movie income, you would like to see."
          f"\nInteger value 1 to {get_num_directors()}.")

    # proceed based on user choice of director or actor
    if choice == 1:

        # get user limit input, with data validation
        # i.e. num no greater than number of directors
        limit = get_num_input(1, (get_num_directors()+1), False)

        # create data frame from our data set
        df = pd.read_csv("/Users/colinoriordan/PycharmProjects/PDA_A02/venv/movie_metadata.csv")

        # create data frame from desired columns
        df_dir_gross = df[["director_name", "gross"]]

        # group data frame by director name
        sorted_df = df_dir_gross.groupby("director_name")

        # set display option of results to integer - was printing in sci. notation
        pd.set_option('display.float_format', lambda x: '%d' % x)

        # get the sum of the gross per director
        summed_df = sorted_df['gross'].sum()

        # put the series into ascending order
        ascending_df = summed_df.sort_values(ascending=False)

        # print results limited to user input
        print()
        print(ascending_df[:limit])

    else:

        # get user limit input, with data validation
        # i.e. num no greater than number of actors
        limit = get_num_input(1, (get_num_actors() + 1), False)

        # create data frame from our data set
        df = pd.read_csv("/Users/colinoriordan/PycharmProjects/PDA_A02/venv/movie_metadata.csv")

        # create data frames from desired columns
        df_actor1_gross = df[["actor_1_name", "gross"]]
        df_actor2_gross = df[["actor_2_name", "gross"]]
        df_actor3_gross = df[["actor_3_name", "gross"]]

        # concatenate the data frames
        frames = [df_actor1_gross, df_actor2_gross, df_actor3_gross]
        concatenated_df = pd.concat(frames)

        print(concatenated_df)

        '''
        # group data frame by director name
        sorted_df = concatenated_df.groupby("")

        # set display option of results to integer - was printing in sci. notation
        pd.set_option('display.float_format', lambda x: '%d' % x)

        # get the sum of the gross per director
        summed_df = sorted_df['gross'].sum()

        # put the series into ascending order
        ascending_df = summed_df.sort_values(ascending=False)

        # print results limited to user input
        print()
        print(ascending_df[:limit])
        '''



def get_num_directors():
    '''
    Function which calculates the number of directors in the movies_metadata
    data set.

    :return: the number of directors in the data set
    '''

    df = pd.read_csv("/Users/colinoriordan/PycharmProjects/PDA_A02/venv/movie_metadata.csv")

    df_dir_gross = df[["director_name", "gross"]]

    sorted_df = df_dir_gross.groupby("director_name")

    return len(sorted_df)


def get_num_actors():
    '''

    :return:
    '''


main_menu()
